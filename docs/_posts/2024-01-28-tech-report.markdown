---
layout: post
title:  "weekly report"
date:   2024-01-28 22:30:08 +0800
categories: weeklyreport
---


# 读书

### 大话存储
继续快照部分的内容, 本周详细看了卷克隆, 其实本质上跟快照区别不大. 简单来说就是可以将快照当成不可变读写层来使用. 某种意义上有点像 overlay mounttype. 比如如下场景
```
1. A 盘创建一个快照 snapshotA
2. SnapshotA 被 HostA 使用, 挂载到了某一个路径下. 
3. 某一个时刻 HostA 对 F 盘的第一个扇区全写 0, 
4. 存储系统收到这个请求后. 会将这 512B 的数据重定向地写入一个空闲存储空间的地址.
5. 更新 metadata 的指针, 指向这个新地址 
```
以上克隆卷称为虚克隆. 因为新盘和旧盘共用一个数据. 如果旧盘被删掉了.新盘的数据也就不存在了, 实克隆相对来说多了一个步骤. 叫做 split clone. split 完成之后,就会生成一个实实在在的真正的物理卷上独立于源卷的卷.

然后又看了下 CDP(Continuous Data Protext). 这里可以分为文件系统级别的 CDP 和 块系统级别的 CDP. 本身因为文件系统自己有相关日志的记录, (只不过日志是循环的, 并非归档模式).并且文件系统默认只记录元信息, 并不是记录实际数据, 所以要实现一个文件系统级别的 CDP, 需要修改这个文件系统/再外加一个新的模块专门做这个. 
主要还是看块级别的 CDP, 这个在 linux 内核中是有专门的模块负责实现这个功能的. 在 CDP 实现中, 主要包含如下三个设备.

- 主机磁盘设备
- CDP 仓库设备
- CDP 元数据设备

详细的就不多说了, 大概原理就是对每一次 IO 操作都做一次 RoW. 然后每一次操作都要有具体的时间戳. 这样的话就可以根据时间来回溯, 重放这些数据.可以说这个时间戳是 CDP 的核心也不为过. 当然, 这个就相当于每一次写 io 都有一次旁路的写操作, 所以成本自然也就相当多, 这个捕获的动作是由卷管理层下方的`块 IO 捕获虚拟设备`完成的, 当然这个设备会拦截所有声明了要做 CDP 的块设备的 IO. 将对应的数据和 LBA 地址段信息发送到 CDP 服务器端. 如果不是相关的数据的话, 就会直接 bypass 这两层处理器, 直接写入目标数据块





# 社区

这周社区没有什么新进展, 本来这周有一个周会的. 但是还是没有准备好, 所以导致还是没有胆量来提问, 下次就是过年前了. 不知道到时候会咋样


# 工作

gpt4 真好用

### 查看 orphan inodes

losf -a +L1 可以显示当然所有的 orphan inodes . 它的原理就是遍历 /proc/fd 下的所有文件描述符, orphan inodes 对应的文件描述符都有特别的标志. 所以可以列出文件

### run 目录

(完全忘了) /var/run 是 /run 目录的软链, /run 中的数据在内存中, 并且重启就会清理.

### invalid go version '1.21.6': must match format 1.23

这周在打镜像的时候, 发现了上面的错误, 一开始很蒙蔽. 上网查了一圈也没有什么结论, 后来尝试升级 Dockerfile build phase 的 go 版本, 跟 go mod 版本对齐之后, 就好了


### kubernetes pki

大多数的整数都存储在这一个路径. 还有一些用户的证书被放到了/etc/kubernetes 目录下
