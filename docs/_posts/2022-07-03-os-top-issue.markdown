---
layout: post
title:  "OS CPU利用率误区"
date:   2022-07-03 22:30:08 +0800
categories: blog
---


### 背景

在平时的运维工作中, 经常有一个经验, 一般压测只会压到 CPU 使用率的 50%. 并不会直接压测到 top 结果的 100%. 这里简单写一篇文档介绍一下, 也算是给自己留一条记录吧

### 硬件超线程技术

这背后的原因其实是因为, 在芯片厂商在制造芯片的时候为了将芯片的效率发挥到极致研发了一种叫做 Simultaneous Multi-Threading(SMT) 的技术, 简单来说其实就是将每一个物理 CPU 都变成了几个虚拟 CPU(虚拟线程). 然后每一个虚拟的 CPU 都可以单独的运行 CPU 指令. 但是这些虚拟 CPU 都是共用的同一个物理 CPU 的逻辑计算单元. 这个在 Intel x86 CPU 的实现是 HT(Hyper-Threading). 每一个物理 CPU 对应着两个超线程. intel 官方说使用了这个技术之后, 机器整体性能提高到了 10%-15%. 

### 为什么性能会提升?

那么为什么在 intel 上开启了这个 HT 的开关之后,性能就提高了 10%左右呢? 或者更加具体来说, 是在什么场景下才会提高?

简单来说,其实中心思想跟我们在 python2 中使用协程是一个概念, 总所周知, python2 由于全局解释锁的原因, 无法发挥多线程的优势, 但是即使如此, 使用协程(线程), 依旧对程序运行效率(尤其是后端服务类型)依旧有着极大的提高. 原因就是 io 访问. 或者是其他需要线程等待的请求. 当一个协程访问 io, 这个协程就会进入等待状态, 如果没有另一个协程运行. 这个协程就会一直等待 io 完成, 这时 CPU 的时间片就会完全被浪费掉. 显然, 如果有另一个协程利用上这段时间, CPU 整体的利用率就会提高. 

同理, 对于同一个 CPU 开启两个 HT 的意思也是为了在一个 HT 因为等待 io 或者其他原因陷入沉默的时候, 另一个 HT 可以利用起这个 CPU 时间片


### 这个对 TOP CPU 使用率的影响是?

在软件层面, 通常 OS 将 HT 当做逻辑 CPU 使用, 在 Linux 操作系统上 ```cat /proc/cpuinfo``` 可以看到的 CPU 的编号默认就是 HT 的编号

![cpuinfo](/asserts/img/cpu-info.jpg)



但是这里有一个问题, OS 并不区分硬件线程的执行能力, 对它来说所有的 硬件线程都是一样的, 也就是它可能分配两个 os 线程到使用同一个物理 CPU 的硬件线程上, 也可能分配到两个不同的 物理CPU的硬件线程上. 这就会导致一个问题, 当我们的压测逐渐加大压力的时候, 他们的表现也是完全不一样的. 当压到某个极致同样的吞吐, 在某些情况下 CPU 的使用率是 50%(所有进程都分配到单独的物理 CPU 上), 某些情况下 CPU 的使用率是 100%(进程将所有 HT 都占满了)

