---
layout: post
title:  "weekly report"
date:   2023-11-11 22:30:08 +0800
categories: weeklyreport
---


# 读书

### 大话存储

#### 备份
数据保护, 主要可以分为文件级的保护和块级的保护. 

##### 文件级备份

备份软件可以感知到文件这一层, 通过调用文件系统接口备份到另一个介质上. 源文件在块上的分布大概不是连续的, 但是备份的数据基本上在新的块上是连续的. 

##### 块级备份
所谓的块级设备, 就是备份快设备上的每个块, 不管这个块上有没有数据, 或者是块上的数据属于哪个文件. 块级别的备份不考虑也不用考虑文件系统层次的逻辑. 原块设备有多少容量, 就备份多少容量. 在这里块的概念对于磁盘来讲就是扇区, 最典型的实例就是磁盘镜像. 由于不经过文件系统的接口, 直接读取磁盘. 所以相对于文件级别的备份来说, 速度会快很多. 并且备份之后, 原先不连续的数据还是会不连续. 依旧会有很多的碎片

#### 快照

某种意义上的"数据照相机", 依赖文件系统元数据链. 元数据链相对整体数据量很少, 在这里冻结文件系统写入基本上用户是不感知的, 如何保证元数据在冻结之后不被修改? 一旦这些元数据被修改, 冻结的元数据也就没有了意义

method1:
元数据复制完成之后, 所有针对源文件系统的更改文件块均会被重定向到一块空余的空间内存放, 并且在源文件系统的元数据更新对应的指针条目来告诉系统说源文件系统内
某文件的某些块的最新内容其实被重定向到了新的空间内的地址. , 这样就可以永久地讲快照创建瞬间的数据全部冻住, 之后所有的更改都被重定向到剩余空间存放. 此时文件系统内保存了两套元数据链. 一套是源文件系统的, 会被不断地更新. 另一套则是快照时保存下来的永不更新, 并且实际指向的数据也不会被覆盖 这种思路叫 Redirect on First Write(RoFW)

method2:
元数据复制完成之后, 所有针对源文件系统重文件的覆盖写操作均照常执行, 但是在覆盖对应的数据块之前. 需要将被覆盖的数据块内容复制出来. 放到一个额外的空闲空间内存放, 并且要更新之前复制出来的元数据. 指向新的地址. 这样, 快照数据会随着覆盖写入操作的不断进行逐渐被搬离原存储空间, 放到空间空间. 这种叫做 Copy on first Write(CoFW)

#### super block

如果一个文件系统非常庞大, 其元数据量也达到了上 GB 或者 上百 GB. 那么首次元数据复制的时间就是不可接受的. 是否有办法再降低数据量? 当然是有的. 也就是复制元数据链的宗, 也即是根入口块. Super Block, 这个块的地址在底层空间上是绝对恒定的. 这个块有指向下一级元数据链块的指针. 当然如果只复制 SuperBlock, 那么其下级的元数据链自身也要进入 CoFW/RoFW 的流程了



# 工作

### describe pvc 找到引用当前 pvc 的 pod

pvc 的 yaml 上其实没有引用当前 pod 信息的. 那么 describe pvc 的时候发现的 used by 的数据是哪里来的? 其实还是 apiserver 缓存了所有的当前 namespace 的 pod 资源, 一个一个遍历获取的, 所以当一个 namespace pod 特别多的时候, describe 操作会特别吃资源

### 虚拟化相关整理

1. kvm 负责 cpu 和 memory 的虚拟化,  qemu 负责 io 设备的虚拟化. kvm + qemu 可以实现真正意义上的服务器虚拟
2. libvirt 则是调用 kvm 虚拟化技术的接口用于管理的工具

