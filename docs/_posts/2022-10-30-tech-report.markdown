---
layout: post
title:  "weekly report"
date:   2022-10-30 22:30:08 +0800
categories: weeklyreport
---


# 读书

### 闪客的操作系统源码分析

还是路上在看, 这周主要是把第二章硬件初始化的内容复习了一遍, 也开始进入了第三章的内容.也就是如何创建一个新进程.

这里大概捋一下顺序,

- 因为这里是首次从内核级别进程切换到用户态进程. 所以需要通过设置一个假的中断返回的方式来切回用户态
- 然后新进程会从老进程的信息直接复制
    - 需要注意的是这里的内存分布
        - 首先进程信息是保存在 gdt 中, 每一个进程会对应一个 tss & ldt 结构
        - ldt 包含代码段和数据段. 相关的线性地址对应的是不一致的, 因为段基地址不同
        - 关于页表信息 子进程复制了父进程的页表信息, 但是这里做了一些手脚, 使得父子进程映射到同一个物理空间, 并且变为只读状态(copy on write)
        - 如果要对数据进行变更, 则新建一个0x14号缺页中断, 中断处理程序进行处理
            - 如果一个进程开始写数据块, 则 创建一个新页表, 将数据 copy 过去, 进行变更,将线程的线性空间的地址指向新创建的页表空间
            - 这时源数据块的指向变为 1, 另一个进程就可以随意对这个数据块进行读写了
- 这个过程中子进程的状态是不可调度的. 因为还没有ready

#### 再总结一下进程调度

简单来说还是 tss 的链表结构. 一般有两种进程调度方式
- do timer, 定时器的主动进程调度
   - 每 10ms 触发一次中断, 中断处理函数检查当前进程的 counter 参数, 当 counter 参数减少为 0 的时候调用 schedule 函数从链表中选择一个 counter 最大(优先级最高)的进程进行调度. 当 counter 减少为 0 的时候恢复 进程的默认 counter 值
- 进程主动放弃cpu 运行权利
    - 这个一般就是因为触发系统调用或者是进行 io 读写

### 大话存储

还在啃.

# 日常

这周一直在忙一些没有营养的事情, 没有什么积累