---
layout: post
title:  "weekly report"
date:   2023-01-27 22:30:08 +0800
categories: weeklyreport
---

开始过节模式, 东西不多, 简单写一写

# 读书

### 大话存储

本周无进展

### 30 天自制操作系统

在路上读了两个章节, 都是显存相关的, 但是  对我来说更有意义的是这两个章节里面 C 语言的基础知识(当然可能当初学的时候就没学懂

指针估计大家都很熟悉了, 简单来说就是指向一块内存的地址的变量它是以如下方式声明的

```
int *test
```
上面的语句声明了一个名字叫做 test int 类型的指针. 

首先第一个点, 指针是一个地址, 地址的长度都是固定的, 为什么还要带一个类型标识, 因为指针变量保存的地址是实际变量的开头, 光有地址可不行, 必须知道实际变量的长度, 否则根本无法取出对应的值. 这就是类型声明的作用, 如下图.

![pointer](/assets/img/pointer.jpg)

第二个点, 我们对指针进行加法. 比如

```
int a
int *p
p = &a
p = p + 1
```
这里 p 的值为 p 源值 + 一个 int 类型的长度之后的地址, 并不是直接加一. 所以指针变量的加法都是加一个类型的长度. 仔细想一下是不是跟宿主比较类似? 上面的 p + 1 可以缩写成如下形式
```
p[1]
```
所谓的数组声明,其实就是保存一连串的数据的最开头的地址. 数组后面的下标说白了就是开头地址加上 数组类型长度 * 数组索引, 得出的就是指向特定数据数据的地址了

当然上面的说法不止适用于基础类型, 同样, 结构体数组也是同样适用的.

比如正常我要引用一个结构体变量的时候, 需要取值, 然后用 "." 运算符来拿到具体的 field 值, 比如 ```(*teststruct).test```, 注意括号不可以省略, 因为有运算优先级问题. 但是这么写太麻烦, 所以可以直接简写成 ```teststruct->test```

# 工作

### vfio


本周因为工作的原因又一次接触到了 vfio, 简单来说 vfio 就是基于 iommu 来实现的一种可以不通过内核态直接访问设备的方式. iommu 之前已经接触过了, 可以参考 xxx. VFIO 的作用就是通过 IOMMU 以安全的方式来将设备的访问直接暴露到用户空间，而不用专门完成某个驱动等待合并到上游或者使用之前的对 IOMMU 没有感知的 UIO 的框架 原本在虚拟机内的磁盘是要通过软件来模拟的, VFIO 提供了一种方式来将硬件设备直通到虚拟机内部(其实是本身就有的机制). IOMMU 可以限制不让虚拟机内部访问到其他的硬件设备罢了. 基于这个, 我们如果有新设备, 无需将相关驱动合并到 虚拟机 os 的上游, 直接编写相关的 driver , 将设备直通到 vm 内部就可以了. 当然这么做也可以减少在虚拟机中虚拟化外设的开销. 使得整体的数据链路更加快速. 所以 iommu 本质还是提供了安全隔离的功能

---
1029 补充
最近又接触的比较多, 又研究了一下, 发现还是有一些没太弄清楚的. 
vfio 是一个整体的方案(相对独立的) 里面包含 vfio-pci(用于直通设备到 userspace, 具体包括PCI配置空间模拟、PCI Bar空间重定向，Interrupt Remapping等) 和 vfio-iommu (对设备进行安全保护, 包括 DMAP remmaping, 管理 IOMMU 页表). vfio 外层统一被 vfio-interface 包裹. 用户通过 interface 进行功能的使用. vfio 主要有以下三个概念

Group 是IOMMU 能否进行 DMA 隔离的最小硬件单元. 设备直通的时候, 一个 group 里面的设备必须都直通给一个虚拟机, 不能将一个 group 里面的多个设备分配给多个虚拟机. 也不能将部分 device 在 host 上, 部分 device 在 guest 里面.(这样就会给在一个 guest 里面的进程权限访问其他 guest 里面/host 里面的设备)

Device 就是简单当成要直通的设备

Container 是一个和地址空间相关联的概念，这里可以简单把它理解为一个VM Domain的物理内存空间。
